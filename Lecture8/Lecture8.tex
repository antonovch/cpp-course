\documentclass[12pt]{article}
\usepackage{../common/cpp-lectures}

\title{Лекція 8. Управління пам'яттю}

\begin{document}
    %\begin{titlepage}
	\maketitle
	%\end{titlepage}
    \abstract{Ця лекція говорить про одну з найважливіших основних тем, як для C++, так і для будь-якої іншої мови програмування.}

	%\newpage
	\tableofcontents
	%\newpage
	
    \section{Основи}
    Оперативну пам'ять комп'ютера можна уявити як одновимірний масив байтів, які мають одну лінійну адресу -- їх позицію, що часто записується в шістнадцятковій формі. Фізично, вона працює таким чином, що доступ до будь-якої адреси пам'яті займає однаковий час. Це дозволяє зберігати частини даних програми будь-де, не переймаючись завчасним виділенням блоку пам'яті. Для конкретного процесу, що виконується, ця пам'ять доступна за адресою, яка зберігається в об'єкті спеціального типу, що зветься вказівником. Ця пам'ять виділяється під час виконання програми (runtime), тому зветься динамічною, на відміну від статичної пам'яті, яка виділяється операційною системою кожному процесу при старті і має фіксований розмір в вісім мегабайт на більшості Unix-like платформах. Проте, частіше, перша називається купою (heap memory), а друга -- стеком (stack memory). Детальніше про це згодом.

    \section{Вказівники в C++}
    З одного боку, вказівники це звичайні об'єкти, зі своїм типом і розміром\footnote{Це фактично число, розмір не залежить від типу об'єкта на який він вказує, а радше від кількості пам'яті на комп'ютері, щоб було можливо зберігати індекс першого байта.}, а з іншого вони особливі, хоча б тим, що їх тип залежить від типу того самого об'єкта, яким може бути будь-який вбудований тип, або ваш тільки що створений клас. Маркером типа вказівника є зірка ($*$). Наприклад:
    \begin{itemize}
        \item \m{MyType*} -- вказівник на тип (клас) \m{MyType};
        \item \m{const MyType*} -- вказівник на \m{const MyType};
        \item \m{MyType* const} -- константний (незмінний) вказівник на \m{MyType};
        \item \m{const MyType* const} -- константний (незмінний) вказівник на \m{const MyType};
    \end{itemize}
    Константність вказівника означає, як і для будь-якої іншої змінної, що ми не можемо змінити її значення, тобто адресу. Іншими словами, перенаправити його на інший об'єкт. У той час як вказівник на константний тип означає, що ми не можемо модифікувати сам екземпляр, або викликати його неконстантні методи.

    Знову ж таки, якщо створити екземпляр вказівника без ініціалізації, то його ``значенням'' буде якесь довільне число, що буде невірно трактуватись як адреса, яка скоріше за все належить іншому процесу, або є вільною, якщо ми спробуємо його якимось чином використати. Вказівники є ще особливими тим, що вони можуть бути в явно неініціалізованому стані, не вказувати ні на що. Досягається це присвоюванням ключового слова \m{nullptr}.

    Щоб ініціалізувати вказівник, необхідно створити екземпляр його відповідного типу та отримати її адресу за допомогою ключового слова \m{new}.\footnote{Або \m{new[]}, якщо ми створюємо масив.} Наприклад,
    \begin{lstlisting}[language=c++,label=rawptr,caption="Сирі вказівники"]
    #include <iostream>
    int main() {
        
        int* i; // unutilized
        std::cout << "This is a garbage address: " << i << std::endl;
    
        i = new int(42);
        std::cout << "This is the address with my value: " << i << std::endl;
        std::cout << "The value is: " << *i << std::endl;
    
        *i -= 2;
        std::cout << "Now the value is: " << *i << std::endl;
    
        return 0;
    }
    \end{lstlisting}

    Якщо запустити скомпільований файл, то побачимо

    \begin{lstlisting}[language=sh]
        This is a garbage address: 0x7ff7b7390d60
        This is the address with my value: 0x7fde0af05b60
        The value is: 42
        Now the value is: 40
    \end{lstlisting}

    Звичайно, можна отримувати і маніпулювати адресами не тільки динамічної пам'яті, а також і локальної:
    \begin{lstlisting}[language=c++]
        int i = 42;
        int* ptr = &i;
        *ptr -= 2;
        std::cout << "The value of i is: " << i << std::endl;        
    \end{lstlisting}
    На виході побачимо 40. На практиці існують випадки, коли це доцільно, але скоріше за все, якщо ви бачите спокусу маніпулювати адресами стекової пам'яті, то вам варто ретельніше подумати над реалізацією, тому що зазвичай це призводить до великої кількості проблем, які важко відстежити, і до коду, який важко зрозуміти. В цих прикладах ви побачили використання оператора розіменування посилань, $*$, що дає доступ до екземпляру, який знаходиться за цією адресою, а також оператора взяття адреси, $\&$, що повертаю адресу екземпляра, до якого він застосовується. Якщо маємо вказівник на екземпляр якогось класу, то його треба розіменовувати перед тим, як викликати якісь методи, тобто \m{(*ptr).begin()}. Оскільки це доволі часта операція, в C++ для цього існує спеціальний синтаксис, оператор \m{->}, який автоматично здійснює розіменування, тобто \m{ptr->begin()}.

    Цікавим є той факт, що оскільки вказівники є у якомусь розумінні звичайними об'єктами, на них також можна посилатись за допомогою своїх вказівників. У такому випадку додається відповідно ще одна\footnote{Або більше, якщо це вказівник на вказівник на вказівник...} зірка до типу, та оператор розіменування застосовується двічі, оскільки першого разу ми отримаємо нову адресу. Наприклад
    \begin{lstlisting}[language=c++]
    int i = 42;
    int* ptr = &i;
    int** ptr_to_ptr = &ptr;
    **ptr_to_ptr *= 2;
    std::cout << "The new value is: " << **ptr_to_ptr << std::endl;
    \end{lstlisting}

    \subsection{Вказівники, що не володіють пам'яттю (сирі)}
    Вказівники, які ви бачили до цього моменту, звуться сирими (іноді ще голими), тобто такими, що ніяк не управляють пам'яттю, на яку вказують, а просто тримають до неї адресу, тим самим даючи доступ. Управління або володіння тут не означають, що такий вказівник повинен бути принципово іншим, а радше, що він мусить мати додатковий інтерфейс поверх звичайного вказівника, який ставить умови для роботи з пам'яттю. Але про це згодом. Сирі вказівники не викликають інструменти управління пам'яттю C++, а саме оператори \m{new} та \m{delete}. Якщо ми вже бачили роботу оператора \m{new} вище, то про оператор \m{delete} варто сказати, що він використовується для звільнення отриманої пам'яті.\footnote{Так само, як і для \m{new}, наряду зі звичайним \m{delete} існує також \m{delete[]} для вказівників на масиви.} За великим рахунком, на кожен виклик \m{new} повинен бути один, і тільки один, виклик \m{delete},\footnote{За великим рахунком, не є великою проблемою, якщо \m{delete} не буде явно викликатись на ту пам'ять, яка використовуються на протязі всього часу виконання програми, тому що, при її завершені, вся пам'ять вивільняється автоматично, але на це не варто розраховувати.} чого ми не побачили в лістингу \ref{rawptr}, що може призвести до так званого витоку пам'яті, про який ми поговоримо в наступній секції.

    \subsection{Потенційні проблеми при використанні сирих вказівників}
    Ситуація, зображена в лістингу \ref{rawptr} -- це приклад витоку пам'яті (memory leak), де чотири байти, що були виділені операційною системою для процесу нашої програми на число, вказівник до якого ми зберігали в локальній змінній $i$, не вивільнились після того, як ми завершили роботу з $i$, і ми опинились в ситуації, коли ні цей процес, ні будь-який інший на цьому комп'ютері, не може їх використати.

    Друга типова проблема, це так званий висячий вказівник (dangling pointer). Це, можна сказати, зворотна ситуація, коли пам'ять вже вивільнилась, а вказівник ще доступний користувачеві. Небезпечно це тим, що розіменування такого вказівника призведе до невизначеної поведінки: для простих вбудованих типів, ми можемо отримати значення за замовченням, або якесь довільне значення (шум) і навіть не зрозуміти, реальне це значення, чи ні, або, і це насамперед для класів, це може призвести до термінової зупинки роботи програми. Щоб не трапилось, той факт, що до цього дійшло, є логічною помилкою. Наприклад,
    \begin{lstlisting}[language=c++,label=dangling,caption="Висячий вказівник"]
    #include <iostream>
    int main() {
        int* i = new int(42);
        // use data
        (*i)++;
        // release data
        delete i;
        // further use is undefined behavior
        std::cout << "The value is: " << *i << std::endl;
    
        return 0;
    }
    \end{lstlisting}

    Остання найбільш поширена ситуація, це так зване подвійне вивільнення пам'яті (double free corruption), тобто ситуація, коли оператор \m{delete} (або \m{delete[]}) викликається другий раз на одну і ту саму адресу. Коли програма має більше однієї логічної одиниці (що охоплює за великим рахунком їх всі), то іноді автор програми може збитися з пантелику, при намаганні самотужки відстежити де саме повинна вивільнятися пам'ять.

    Також, через те, як побудовані масиви в C, не завжди може бути зрозуміло чи ми працюємо зі вказівником на один елемент, чи на масив, що важливо, щоб розуміти треба викликати \m{delete} або \m{delete[]}. Використання неправильного оператора призводить до невизначеної поведінки.
    
    Для запобігання цих ситуацій, важливо поєднати час життя вказівників на стеку, та об'єктів, на які вони вказують, в купі. Це називається принципом RAII в C++ (Resource allocation is initialization). В стандартній бібліотеці C++ його реалізовано у вигляді так званих розумних вказівників, про яких ми поговоримо на наступних секціях.

    \section{Вказівники і класи}
    Окремо зупинимось на тому, яку роль вказівники грають при роботі з класами.

    Ми вже бачили, що коли в нас є вказівник на екземпляр будь-якого класу, ми можемо викликати його метод, або звернутись до елементу даних за допомогою оператора \m{->}, який поєднує розіменування (оператор \m{*}) з викликом (оператор \m{.}).

    Коли ми розробляємо код якогось методу класу, часто там необхідно звернутись до якогось іншого методу, або елементу даних об'єкта, що викликав цей метод.\footnote{Інакше цей метод скоріше за все був би статичним, тобто таким, який не прив'язаний до конкретного екземпляру.} В багатьох інших мовах програмування це досягається тим, що методи функцій мають перший обов'язковий аргумент, який є (вказівником, посиланням тощо) екземпляром, що їх викликав. Оскільки часто це є надлишковим, в C++ вказівник на екземпляр передається неявно і є доступним через зарезервовано ключове слово \m{this}. Сам вказівник є завжди \m{const}, а об'єкт, на який він вказує, є таким тільки для методів, що помічаються \m{const}. 
    
    Також, вказівники є тим інструментом, яким досягається динамічний поліморфізм.\footnote{Посилання також є поліморфними, тому знову може постати вибір -- використовувати посилання чи вказівники. Всі ті самі аргументи, що і раніше, є валідними. Найчастіше на практиці це саме вказівники, тому фокус на них і тут.} Тобто, через вказівник на базовий клас, зокрема на інтерфейс, ми можемо писати функції, або інші інтерфейси, які будуть працювати з будь-якою його конкретною реалізацією. Викликатися буде правильна\footnote{Тобто реалізація класу екземпляра, на не вказівника.} версія окремо взятого віртуального методу завдяки \href{https://en.cppreference.com/w/cpp/language/virtual}{віртуальний таблиці}.

    \section{Розумні вказівники}
    Розумні вказівники -- це звичайні об'єкти-обгортки, або надбудови, над сирими вказівниками, що зберігають інтерфейс взаємодії з ними,\footnote{Тобто мають відповідні імплементації для операторів \m{*}, \m{->}, \m{=}, що зокрема дозволяє присвоювати їм \m{nullptr}, та інші.} вводячи певні обмеження та автоматизації, щоб мінімізувати випадки будь-якої з перелічених, і потенційно інших, проблем. Тобто, вони ``керують'' часом життя екземпляра, та запобігають або управляють множинним володінням. \footnote{Іншими словами, ситуація, коли у вказівника є декілька користувачів.} Так само як і сирі вказівники, вони поліморфні.

    На практиці, ми використовуємо фабричні методи, яки викликають оператор \m{new} (або \m{new[]}), отримують вказівник та передають його новоствореному розумному вказівнику, який і повертається. Пам'ять вивільняється деструктором розумного вказівника при його видаленні на стеку, або при роботі окремих його методів, коли треба видалити або перезаписати сирий вказівник, що знаходиться всередині. Через автоматичне вивільнення пам'яті, розумні вказівники не можна використовувати для вказування на екземпляри зі стеку.\footnote{Брати адресу стекових об'єктів взагалі може бути ризикованою справою, але іноді це необхідно або корисно. Для цього доречно використовувати сирі вказівники -- як мінімум ми не зіштовхнемося з витоком пам'яті, бо стекові об'єкти видаляються автоматично при виході зі своєї області, а пам'ять залишається належати програмі на весь час її виконання у будь-якому разі.}

    В стандартній бібліотеці є три види розумних вказівників: \m{std::unique\_ptr}, \m{std::shared\_ptr}, та \m{std::weak\_ptr}. Це шаблони класів, головним параметром яких є тип, на який він вказує.\footnote{Другим параметром є функтор (клас, екземпляри якого мають оператор виклику, як функції), який задає логіку видалення об'єкту. У переважній більшості випадків ми нічого не передаємо і користуємось видаленням за замовченням, що реалізована в класі \href{https://en.cppreference.com/w/cpp/memory/default_delete}{default\_delete}, який використовує оператор \m{delete}. Але розумні вказівники можна використовувати не тільки для об'єктів в купі, а для багато іншого також. Наприклад, файли чи мережеві з'єднання. Коли ми відкриваємо файл чи налаштовуємо з'єднання, їх важливо закрити в кінці. Цю логіку можна імплементувати в окремому класі в передати розумному вказівнику.} Про кожен ми поговоримо окремо далі.

    \subsection{std::unique\_ptr}
    Якщо вирішення задачі потребує використання вказівників, то першим кандидатом на цю роль повинен бути \href{https://en.cppreference.com/w/cpp/memory/unique_ptr}{\m{std::unique\_ptr}}. Конструктор його приймає голий вказівник на об'єкт, який він приймає під своє управління. Проте, як було зазначено, чистіше і безпечніше для таких цілей використовувати фабричні методи, а саме \href{https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique}{\m{std::make\_unique}}. Це шаблон функції, яка приймає ті самі аргументи, що і конструктор, який ми хочемо викликати, для типу, за яким він параметризується. Наприклад,
    \begin{lstlisting}[language=c++]
    auto myClassPtr = std::make_unique<MyClass>(1, "A", true);
    // auto is resolved to std::unique_ptr<MyClass>
    // equivalent to 
    // std::unique_ptr<MyClass> myClassPtr(new MyClass(1, "A", true));
    \end{lstlisting}

    Як можна зрозуміти з його назви, цей розумний вказівник реалізує концепт, коли він є єдиним власником пам'яті. Тобто, його не можна скопіювати, тільки перемістити. Наприклад,
    \begin{lstlisting}[language=c++]
    auto ptr = std::make_unique<std::string>("text string");
    // we can use it
    std::cout << "The text is: " << *ptr << std::endl;
    // we can't copy it
    // auto ptr2 = ptr;
    // we can move it
    auto ptr2 = std::move(ptr);
    // and use the new object from now on
    std::cout << "ptr2 points to: " << *ptr2 << std::endl;
    // ptr is now nullptr
    std::cout << "Is ptr null? " << (ptr ? "false" : "true") << std::endl;
    // as with normal nullptr, we cannot dereference it
    // std::cout << "ptr points to: " << *ptr << std::endl; // this will crash
    \end{lstlisting}

    Сам по собі \m{std::unqiue\_ptr} достатньо простий клас (який не так важко написати самому!), а його використання фактично не додає ніяких додаткових навантажень в скомпільованому коді, в порівнянні з використанням сирих показників. Тому, навіть якщо ви знаєте, що окремо взятий об'єкт необхідний впродовж всього часу виконання програми і його не потрібно буде видаляти, використання \m{std::unique\_ptr} все ще може допомогти запобігти потенційним негараздам. Наприклад, ситуації, коли все ж таки хтось його видалив. Або, якщо логіка програми зміниться, і його час життя скоротиться. На додачу, іншим, хто буде дивитись ваш код не потрібно бути думати і аналізувати, чи не є помилкою використання сирого вказівника в цьому конкретному випадку, чи може це призвести до потенційних проблем.\footnote{Звичка думати про тих, хто може працювати з вашим кодом у майбутньому не тільки позитивно впливатимете на його якість, а ще і збереже час всіх причетних.}



    \subsection{std::shared\_ptr}
    Існують обґрунтовані причини для того, щоб вказівник використовували різні процеси одночасно,\footnote{Тут треба говорити про цілу окрему дисципліну багатопоточного використання спільних ресурсів, але вона виходить за рамки цього курсу.} або ж він зберігався в різних місцях одночасно. Для таких випадів стандартна бібліотека має готове рішення в вигляді \m{std::shared\_ptr}. 
    
    З точки зору реалізації, він набагато складніший за \m{std::unique\_ptr}, тому застосовувати його рекомендовано тільки якщо це дійсно треба, а використовується він так само. \m{std::shared\_ptr} використовує концепцію спільного володіння пам'яттю. А саме, пам'ять виділяється при створенні першої (оригінальної) копії, а видалиться, коли остання копія закінчить своє існування. Їй може бути будь-яка з існуючих. При створенні першої копії \m{std::shared\_ptr}, його конструктор також створює пов'язаний з цим екземпляром об'єкт-лічильник. Потім, при кожному копіюванні через оператор \m{=}, або конструктор копіювання, цей лічильник зростає на одиницю, і аналогічно зменшується завдяки деструктору, аж поки він не буде дорівнювати нулю, коли він\footnote{Який до речі також існує в купі.} сам видаляється і пам'ять вивільняється. З тих самих міркувань, що і у випадку з \m{std::unique\_ptr}, варто використовувати фабричний метод \m{std::make\_shared} для створювання екземплярів \m{std::shared\_ptr}.

    \subsection{std::weak\_ptr}
    Наостанок, варто розглянути третій різновид розумних вказівників, який на справді не є вказівником, \href{https://en.cppreference.com/w/cpp/memory/weak_ptr}{\m{std::weak\_ptr}}. Чим він є, так це способом дістати \m{std::shared\_ptr}, якщо це можливо. Він зручний, коли ми хочемо мати вказівник на ресурс, але не володіти ним, не впливати на його лічильник, щоб його час життя не залежав від цієї копії. Іноді, це трапляється з точки зору якомога швидшого вивільнення пам'яті, або якщо вона логічно невід'ємна від іншого процесу, який мусить її вивільнити по закінченню, або у випадках, коли це технічно необхідно при кругових залежностях. З цього опису повинно бути зрозуміло, що \href{https://en.cppreference.com/w/cpp/memory/weak_ptr/weak_ptr}{конструктор \m{std::weak\_ptr}} приймає відповідний \m{std::shared\_ptr}.

    Як вже булл зазначено, \m{std::weak\_ptr} не є вказівником. Він не реалізує відповідний інтерфейс, і сам по собі не дасть нам доступ до ресурсу. Щоб достукатись до пам'яті, треба спершу отримати на неї \m{std::shared\_ptr}, що можливо зробити за допомогою метода \href{https://en.cppreference.com/w/cpp/memory/weak_ptr/lock}{lock}. На виході, ми отримуємо справжній \m{std::shared\_ptr}, що призведе до збільшення лічильника, але час життя цього \m{std::shared\_ptr} буде меншим за \m{std::weak\_ptr}, що цього створив, тому потенційна ``затримка'' оригінального об'єкту буде мінімальною. Якщо \m{std::shared\_ptr}, на який дивиться наш екземпляр \m{std::weak\_ptr} пустий, тобто ресурс вивільнено, \m{lock} повертає \m{std::shared\_ptr} створений за замовченням, тобто такий, який дорівнює \m{nullptr}. Перевірити цей випадок можна за допомогою метода \href{https://en.cppreference.com/w/cpp/memory/weak_ptr/expired}{expired}.
    


    \sec{Література}
	
	\begin{itemize}
		\item Stroustrup, Bjarne. The C++ programming language. Pearson Education, 2013 (Глави 7, 34).
		\item \href{www.cplusplus.com/doc/tutorial/pointers/}{CPlusPlus, Pointer tutorial}.
		\item \href{https://en.cppreference.com/w/cpp/memory}{CPPReference, Dynamic memory management}.
	\end{itemize}

\end{document}
